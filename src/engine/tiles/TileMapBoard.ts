import { Vec2d } from "..";
import { EngineError } from "../EngineError";
import { TileType } from "./TileType";

export type Cell = {
  spriteSheetPosition: number;
  type: TileType;
};

const defaultSpriteSheetPosition = -1;

/**
 * TileMpaBoard represents the tile map used to display on the screen. It is generated by the editor.
 * The idea is to make simple to see the binary tilemap through it. As convention, we follow the
 * concept of left bottom origin of the world.
 *
 * Here is an example of tilemap. You can see a square of 1's in the center, starting at (1, 1), with 3 rows and 4 columns:
 *
 * row
 * 4  00  00  00  00  00  00
 *    00  00  00  00  00  00
 *
 * 3  00  11  11  11  11  00
 *    00  10  00  00  01  00
 *
 * 2  00  10  00  00  01  00
 *    00  10  00  00  01  00
 *
 * 1  00  10  00  00  01  00
 *    00  11  11  11  11  00
 *
 * 0  00  00  00  00  00  00
 *    00  00  00  00  00  00
 *
 *     0   1   2   3   4   5 column
 */
export class TileMapBoard {
  readonly rows: number;
  readonly columns: number;
  private readonly cells: Cell[][] = [];

  constructor(rows: number, columns: number) {
    this.rows = rows;
    this.columns = columns;

    for (let row = 0; row < rows; row++) {
      this.cells.push([]);
      for (let column = 0; column < columns; column++) {
        this.cells[row].push({
          spriteSheetPosition: defaultSpriteSheetPosition,
          type: TileType.Empty,
        });
      }
    }
  }

  get(row: number, column: number) {
    if (row < 0 || row >= this.rows || column < 0 || column >= this.columns) {
      throw new EngineError(
        TileMapBoard.name,
        `The position supplied (${row}, ${column}) is outside the board range from (0, 0) to (${this.rows}, ${this.columns})`
      );
    }
    return this.cells[row][column];
  }

  setTileType(row: number, column: number, type: TileType) {
    if (row < 0 || row >= this.rows || column < 0 || column >= this.columns) {
      throw new EngineError(
        TileMapBoard.name,
        `The position supplied (${row}, ${column}) is outside the board range from (0, 0) to (${this.rows}, ${this.columns})`
      );
    }

    this.cells[row][column].type = type;
  }

  merge(position: Vec2d, anotherBoard: TileMapBoard) {
    if (
      position.y < 0 ||
      position.y >= this.rows ||
      position.x < 0 ||
      position.x >= this.columns
    ) {
      throw new EngineError(
        TileMapBoard.name,
        `The initial position supplied (${position.y}, ${position.x}) is outside the board range from (0, 0) to (${this.rows}, ${this.columns})`
      );
    }

    if (
      position.y + anotherBoard.rows > this.rows ||
      position.x + anotherBoard.columns > this.columns
    ) {
      throw new EngineError(
        TileMapBoard.name,
        `The final position of the merge (${position.y + anotherBoard.rows}, ${
          position.x + anotherBoard.columns
        }) is outside the board limits at (${this.rows}, ${this.columns})`
      );
    }

    for (let row = 0; row < anotherBoard.rows; row++) {
      for (let column = 0; column < anotherBoard.columns; column++) {
        this.mergeCell(
          row + position.y,
          column + position.x,
          anotherBoard.get(row, column).type
        );
      }
    }
  }

  private mergeCell(row: number, column: number, type: TileType) {
    if (this.cells[row][column].type == TileType.Empty) {
      this.cells[row][column].type = type;
    } else {
      this.cells[row][column].type &= type;
    }
    this.cells[row][column].spriteSheetPosition = defaultSpriteSheetPosition;
  }

  overrideBy(position: Vec2d, anotherBoard: TileMapBoard) {
    for (let row = 0; row < anotherBoard.rows; row++) {
      for (let column = 0; column < anotherBoard.columns; column++) {
        const anotherCell = anotherBoard.get(row, column);
        if (anotherCell.type !== TileType.Empty) {
          this.cells[row + position.y][column + position.x] = anotherCell;
        }
      }
    }
  }

  forEachCell(action: (cell: Cell) => void) {
    for (let row = 0; row < this.rows; row++) {
      for (let column = 0; column < this.columns; column++) {
        action(this.cells[row][column]);
      }
    }
  }
}
